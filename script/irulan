#!/usr/bin/env perl
#
# irulan - interacts with the Web::Irulan SSH host key database

use 5.16.0;
use warnings;
use open IN => qw(:bytes);
use Data::SSHPubkey qw(pubkeys);
use Data::UUID;
use Getopt::Long qw(GetOptions);
use Mojo::SQLite;
use NetAddr::IP qw(:lower);    # 'lower' due to RFC 5952
use Scalar::Util qw(looks_like_number);
use Socket qw(:addrinfo SOCK_RAW);
use Text::ParseWords qw(shellwords);
use FindBin;
BEGIN { unshift @INC, "$FindBin::Bin/../lib" }
use Web::Irulan::Model::Hostkeys;

my $msl = Mojo::SQLite->new->from_filename($ENV{IRULAN_DB_PATH} // 'irulan.db');
my $db  = Web::Irulan::Model::Hostkeys->new(sqlite => $msl);

my ($Flag_NoLookup, $Flag_PostCmd);

# had planned an "audit" command to check known_hosts records but
# that is probably best handled by other tools that can iterate
# through the ssh_known_hosts output and check as necessary that the
# host keys are valid
#
# had also planned on "tags" to support selection of particular sets of
# known hosts, but that could also be done by grep or such also against
# the ssh_known_hosts output, e.g. so that internal systems see
# different sets of host keys than external clients who only get gateway
# systems, etc
my %commands = (
    addhost => sub {
        my ($cmd) = @_;
        my $sysid = $ARGV[0];
        my ($host, $port) = hostport(@ARGV[ 1, 2 ]);
        die "Usage: irulan addhost sysid hostname [port]\n"
          if !defined $sysid
          or $sysid !~ m/^\d+$/a
          or !defined $host;
        if (!$Flag_NoLookup) {
            die "irulan: no IP associated with $host\n" unless ip_addrs($host);
        }
        $db->add_host($sysid, $host, $port);
        exec_postcmd($cmd);
    },
    cat => sub {
        my %pubkeys;
        if (@ARGV) {
            my $done_stdin = 0;
            for my $arg (@ARGV) {
                if ($arg eq '-' and !$done_stdin) {
                    @pubkeys{ map { $_->[1] } read_from_fh() } = ();
                    $done_stdin = 1;
                } else {
                    open my $fh, '<', $arg or die "irulan: could not open $arg: $!\n";
                    @pubkeys{ map { $_->[1] } read_from_fh($fh) } = ();
                }
            }
        } else {
            @pubkeys{ map { $_->[1] } read_from_fh() } = ();
        }
        die "irulan: no pubkeys parsed\n" unless %pubkeys;
        $db->add_system(Data::UUID->new->create_str, 'cat ' . time(),
            [ keys %pubkeys ]);
    },
    keyscan => sub {
        my ($host, $port) = hostport(@ARGV);
        die "Usage: irulan keyscan hostname [port]\n" if !defined $host;
        my @command = (qw(ssh-keyscan -p), $port);
        open(my $fh, '-|', @command, '--', $host)
          or die "irulan: @command failed: $!\n";
        my @pubkeys = read_from_fh($fh);
        die "irulan: no pubkeys parsed\n" unless @pubkeys;
        $db->add_system(
            Data::UUID->new->create_str,
            ($port == 22 ? $host : "$host $port"),
            [ map { $_->[1] } @pubkeys ]
        );
    },
    list => sub {
        my $ret = $db->hosts;
        my %seen;
        while (my $host = $ret->hash) {
            my $hp = $host->{hostname} . ':' . $host->{port};
            warn "duplicate entry for $hp" if $seen{$hp}++;
            say $host->{sysid}, ' ', $host->{hostname},
              ($host->{port} == 22 ? '' : ' ' . $host->{port});
        }
    },
    rmhost => sub {
        my ($cmd) = @_;
        my ($host, $port) = hostport(@ARGV);
        die "Usage: irulan rmhost hostname [port]\n" if !defined $host;
        $db->remove_host($host, $port);
        exec_postcmd($cmd);
    },
    rmsystem => sub {
        my ($cmd) = @_;
        my $sysid = $ARGV[0];
        die "Usage: irulan rmsystem sysid\n"
          if !defined $sysid or $sysid !~ m/^\d+$/a;
        $db->remove_system($sysid);
        exec_postcmd($cmd);
    },
    ssh_known_hosts => sub {
        my $notbefore = $ARGV[0];
        if (defined $notbefore and length $notbefore) {
            die "irulan: invalid epoch value\n" if !looks_like_number $notbefore;
            exit 2 if $db->most_recent <= int $notbefore;
        }
        my $s   = '';
        my $ret = $db->known_hosts;
        while (my $h = $ret->hash) {
            my $alts = alternize($h->{hostname}, $h->{port});
            say $alts, ' ', $h->{pubkey};
        }
    },
    unhosted => sub {
        my $ret = $db->unhosted;
        while (my $sys = $ret->hash) {
            say join ' ', map { $sys->{$_} } qw(sysid uuid info);
        }
    },
);

# this catches flags before or after the command as I found myself using
# both locations while writing the tests
GetOptions(
    'help|h|?' => \&emit_help,
    'n'        => \$Flag_NoLookup,
    'P=s'      => \$Flag_PostCmd,
);
my $cmd = shift;
emit_help() unless defined $cmd and exists $commands{$cmd};
$commands{$cmd}->($cmd);

# hostname -> hostname,ip; ip -> ip; host:2222 -> [host]:2222,[ip]:2222; etc
sub alternize {
    my ($host, $port) = @_;
    my %alts;
    # NOTE canon() necessary here as the OpenSSH client does simple
    # string matching on the known_hosts data; that is, OpenSSH will not
    # match 2001:0db8:0000:0000:0000:0000:c000:022a but will match
    # 2001:db8::c000:22a. the following assumes that $host is either a
    # hostname or already a IP address in canonical form
    @alts{
        $host, map { NetAddr::IP->new($_)->canon } $Flag_NoLookup ? () : ip_addrs($host)
    } = ();
    # TODO may want more complicated sort that puts the hostname (if
    # any) before the IP addresses, KLUGE done here via a reverse sort
    return join ',',
      map { $port == 22 ? $_ : "[$_]:$port" } sort { $b cmp $a } keys %alts;
}

sub emit_help {
    say STDERR "Usage: irulan command [cmd-args ..]\n  commands: " . join ', ',
      sort keys %commands;
    exit 64;
}

sub exec_postcmd {
    my ($cmd) = @_;
    if ($Flag_PostCmd) {
        { exec shellwords($Flag_PostCmd), $cmd };
        die "irulan: could not exec $Flag_PostCmd: $!\n";
    }
}

sub hostport {
    my ($host, $port) = @_;
    # NOTE some sites may want stronger verification of hostnames (e.g.
    # that only fully qualified hostnames are supplied)
    undef $host if !defined $host or !length $host;
    if (defined $port and length $port) {
        die "irulan: invalid port number\n" if !looks_like_number $port;
        $port = int $port;
    } else {
        $port = 22;
    }
    return $host, $port;
}

# NIx_* first show up in perl 5.16.0 Socket.pm docs, not in perl 5.14 so
# that's where the minimum version bar is set
sub ip_addrs {
    my ($host) = @_;
    my ($err, @res) = getaddrinfo($host, "", { socktype => SOCK_RAW });
    die "irulan: getaddrinfo failed '$host': $err\n" if $err;
    my @ips;
    while (my $ai = shift @res) {
        my ($err, $ipaddr) = getnameinfo($ai->{addr}, NI_NUMERICHOST, NIx_NOSERV);
        die "irulan: getnameinfo failed '$host': $err\n" if $err;
        push @ips, $ipaddr;
    }
    return @ips;
}

sub read_from_fh {
    my ($fh) = @_;
    @{  pubkeys(
            \do {
                local $/;
                if (defined $fh) { binmode $fh; readline $fh }
                else             { readline }
            }
        )
    };
}
